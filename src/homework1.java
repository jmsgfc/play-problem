import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;
import java.util.regex.*;

/**
 * Copyright © 2025 Wings of Redemption. All rights reserved.
 * 本软件为 Wings of Redemption 个人所有，仅供学习和教学使用，未经许可不得用于商业用途。
 */
class OptimizedQuizApp extends JFrame {
    // 题目字符串（包含多选题）
    String quest = "1.在 OSI 七层结构模型中，处于数据链路层与运输层之间的是（）\n" +
            "\n" +
            "A、物理层\n" +
            "\n" +
            "B、网络层\n" +
            "\n" +
            "C、会话层\n" +
            "\n" +
            "D、表示层\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：OSI 七层模型从下到上依次为物理层、数据链路层、网络层、传输层（运输层）、会话层、表示层、应用层。网络层位于数据链路层之上、传输层之下，主要负责网络互联和数据包的路由选择。\n" +
            "\n" +
            "2.网络时延由哪几部分组成？（）\n" +
            "\n" +
            "A、发送时延\n" +
            "\n" +
            "B、发射时延\n" +
            "\n" +
            "C、处理时延\n" +
            "\n" +
            "D、排队时延\n" +
            "\n" +
            "E、传播时延\n" +
            "\n" +
            "F、共享时延\n" +
            "\n" +
            "答案：ACDE\n" +
            "\n" +
            "解析：网络时延主要包括以下几部分：\n" +
            "\n" +
            "•发送时延：主机或路由器发送数据帧所需的时间。\n" +
            "\n" +
            "•传播时延：电磁波在传输介质中传播所花费的时间。\n" +
            "\n" +
            "•处理时延：主机或路由器处理数据报所花费的时间。\n" +
            "\n" +
            "•排队时延：数据报在路由器缓冲区中排队等待转发的时间。\n" +
            "\n" +
            "发射时延和共享时延并非网络时延的标准组成部分。\n" +
            "\n" +
            "3.数据解封装的过程是（）。\n" +
            "\n" +
            "A. 段 — 包 — 帧 — 流 — 数据\n" +
            "\n" +
            "B. 流 — 帧 — 包 — 段 — 数据\n" +
            "\n" +
            "C. 数据 — 包 — 段 — 帧 — 流\n" +
            "\n" +
            "D. 数据 — 段 — 包 — 帧 — 流\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：数据封装是从应用层到物理层依次添加头部的过程，而解封装则是其逆过程。在解封装时，首先从物理层获取数据流，然后依次剥离数据链路层的帧头、网络层的包头、传输层的段头，最终得到应用层数据，即流→帧→包→段→数据。\n" +
            "\n" +
            "4.计算机网络的功能有（）\n" +
            "\n" +
            "A. 数据通信功能\n" +
            "\n" +
            "B. 分布式处理功能\n" +
            "\n" +
            "C. 远程访问与协同工作功能\n" +
            "\n" +
            "D. 数据存储和备份功能\n" +
            "\n" +
            "E. 资源共享功能\n" +
            "\n" +
            "答案：ABCE\n" +
            "\n" +
            "解析：计算机网络的核心功能包括：\n" +
            "\n" +
            "•数据通信：实现不同设备间的数据传输。\n" +
            "\n" +
            "•资源共享：共享硬件、软件和数据资源。\n" +
            "\n" +
            "•分布式处理：将任务分配给网络中的多台设备协同完成。\n" +
            "\n" +
            "•远程访问与协同工作：支持用户远程接入和多人协作。\n" +
            "\n" +
            "数据存储和备份更多是服务器或存储系统的功能，而非网络的基本功能。\n" +
            "\n" +
            "5.关于 Internet，以下说法正确的是（）。\n" +
            "\n" +
            "A. Internet 属于美国\n" +
            "\n" +
            "B. Internet 属于联合国\n" +
            "\n" +
            "C. Internet 属于国际红十字会\n" +
            "\n" +
            "D. Internet 不属于某个国家或组织\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：Internet 是全球性的开放网络，没有单一的管理机构或归属主体，它由众多网络运营商、组织和用户共同参与构建，不属于任何特定国家或组织。\n" +
            "\n" +
            "6.（）描述了 “物联网” 技术的最准确概念。\n" +
            "\n" +
            "A. 物联网是指通过互联网连接智能设备和物体，使其能够实时交互和共享数据的技术。\n" +
            "\n" +
            "B. 物联网是一种通过蓝牙技术连接多个设备的技术。\n" +
            "\n" +
            "C. 物联网是指通过红外线和无线电频率连接多个设备的技术。\n" +
            "\n" +
            "D. 物联网是指通过有线电缆连接多个设备的技术。\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：物联网的核心是通过互联网将各类智能设备、物体连接起来，实现数据交互和共享，以实现智能化管理和控制。蓝牙、红外线等只是局部连接技术，有线电缆也非物联网的核心特征，A 选项准确概括了物联网的本质。\n" +
            "\n" +
            "7.不属于计算机网络应用的是（）。\n" +
            "\n" +
            "A. 电子邮件的收发\n" +
            "\n" +
            "B. 用 “写字板” 写文章\n" +
            "\n" +
            "C. 用计算机传真软件远程收发传真\n" +
            "\n" +
            "D. 用浏览器浏览 “上海热线” 网站\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：电子邮件收发、远程传真、网页浏览均依赖网络实现，属于网络应用。而用写字板写文章是本地单机操作，不涉及网络通信，不属于计算机网络应用。\n" +
            "\n" +
            "8.关于 5G 技术，（）描述了 5G 技术的特点。\n" +
            "\n" +
            "A. 5G 技术具备极高的网速和低延迟，能够支持大规模连接和快速传输。\n" +
            "\n" +
            "B. 5G 技术只适用于移动通信领域，对其他领域的影响有限。\n" +
            "\n" +
            "C. 5G 技术主要侧重于提供更加稳定的网络连接，而不太注重网络速度提升。\n" +
            "\n" +
            "D. 5G 技术主要针对企业级用户，普通家庭用户受益有限。\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：5G 技术的显著特点是高带宽（极高网速）、低延迟、大连接（支持大规模设备接入），这些特性使其不仅适用于移动通信，还能推动物联网、工业自动化等多领域发展，普通家庭用户也能从高速网络中受益。B、C、D 选项均不符合 5G 的实际特点。\n" +
            "\n" +
            "9.下列（）的描述是正确的。\n" +
            "\n" +
            "A. 云计算技术与计算机网络相互独立，两者可以独立运行而不影响彼此。\n" +
            "\n" +
            "B. 云计算技术与计算机网络没有直接的关系，它只是一种基于虚拟化的资源管理方式。\n" +
            "\n" +
            "C. 云计算技术是建立在计算机网络基础之上的，依赖于网络进行资源的存储和处理。\n" +
            "\n" +
            "D. 云计算技术是通过计算机网络实现资源的集中管理和分配的一种方式。\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：云计算的核心是通过网络将分布式的计算资源、存储资源等集中管理和调度，其运行必须依赖计算机网络来传输数据和交互指令。A、B 选项忽略了网络对云计算的基础性作用，D 选项虽部分正确，但 C 选项更准确地指出了云计算与网络的依存关系。\n" +
            "\n" +
            "10.大数据技术中，（）对于分布式存储和处理大规模数据非常重要。\n" +
            "\n" +
            "A. 路由\n" +
            "\n" +
            "B. 数据传输\n" +
            "\n" +
            "C. 带宽控制\n" +
            "\n" +
            "D. 负载均衡\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：在大数据分布式系统中，负载均衡用于将数据存储和处理任务均匀分配到多个节点，避免个别节点过载，确保系统高效稳定运行。路由、数据传输和带宽控制虽也是关键环节，但负载均衡直接关系到分布式架构的性能和可靠性。\n" +
            "\n" +
            "11.在数据通信中，将数字信号变换为模拟信号的过程称为（）。\n" +
            "\n" +
            "A．编码\n" +
            "\n" +
            "B．解码\n" +
            "\n" +
            "C．解调\n" +
            "\n" +
            "D．调制\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：调制是将数字信号转换为模拟信号的过程，以便在模拟信道中传输；解调则是相反过程，将模拟信号还原为数字信号。编码是将信息转换为数字信号的格式，解码是其逆过程。\n" +
            "\n" +
            "12.如果对某模拟信号进行采样后，使用 128 个量化级，则用（）比特表示结果。\n" +
            "\n" +
            "A、256\n" +
            "\n" +
            "B、128\n" +
            "\n" +
            "C、8\n" +
            "\n" +
            "D、7\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：量化级数量与所需比特数的关系为：2^n ≥ 量化级数（n 为比特数）。128 个量化级对应 2^7 = 128，因此需要 7 比特。\n" +
            "\n" +
            "13.在同一个信道上的同一时刻，能够进行双向数据传送的通信方式是（）。\n" +
            "\n" +
            "A. 单工\n" +
            "\n" +
            "B. 半双工\n" +
            "\n" +
            "C. 全双工\n" +
            "\n" +
            "D. 上述三种均不是\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：全双工通信允许在同一时间双向传输数据，如电话通话；半双工通信允许双向传输，但同一时间只能单向进行，如对讲机；单工通信只能单向传输，如广播。\n" +
            "\n" +
            "14.下列交换技术中，节点不采用 “存储 — 转发” 方式的是（）。\n" +
            "\n" +
            "A、电路交换技术\n" +
            "\n" +
            "B、报文交换技术\n" +
            "\n" +
            "C、虚电路交换技术\n" +
            "\n" +
            "D、数据报交换技术\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：电路交换在通信前需建立专用物理链路，通信过程中数据直接传输，不进行存储转发。报文交换、虚电路和数据报交换均采用存储转发方式，节点接收数据后暂存，再根据路由转发。\n" +
            "\n" +
            "15.常用的互联网接入方式有（）\n" +
            "\n" +
            "A、电话拨号\n" +
            "\n" +
            "B、光纤\n" +
            "\n" +
            "C、ADSL\n" +
            "\n" +
            "D、有线电视\n" +
            "\n" +
            "E、以太网\n" +
            "\n" +
            "F、无线 WIFI\n" +
            "\n" +
            "G、5G，4G\n" +
            "\n" +
            "答案：ABCDEFG\n" +
            "\n" +
            "解析：以上均为常见的互联网接入方式：\n" +
            "\n" +
            "•电话拨号：通过传统电话线接入。\n" +
            "\n" +
            "•光纤：利用光纤传输高速数据。\n" +
            "\n" +
            "•ADSL：基于电话线的宽带接入。\n" +
            "\n" +
            "•有线电视：通过同轴电缆接入。\n" +
            "\n" +
            "•以太网：局域网常用接入方式。\n" +
            "\n" +
            "•无线 WIFI：通过无线信号接入。\n" +
            "\n" +
            "•5G/4G：移动通信网络接入。\n" +
            "\n" +
            "1.专线方式接入 Internet 时，可以按照实际通信量（即每月传送了多少字节数据）来计费，这是因为（）。\n" +
            "\n" +
            "A. 采用电路交换技术\n" +
            "\n" +
            "B. 采用报文交换技术\n" +
            "\n" +
            "C. 采用分组交换技术\n" +
            "\n" +
            "D. 采用同步传输技术\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：分组交换将数据分割为分组传输，按数据量（字节数）计费更合理。电路交换按通信时间计费，报文交换和分组交换类似但较少用于专线接入，同步传输是一种传输方式，与计费方式无关。\n" +
            "\n" +
            "1.在计算机网络中，表征数据传输有效性的指标是（）。\n" +
            "\n" +
            "A. 误码率\n" +
            "\n" +
            "B. 频带利用率\n" +
            "\n" +
            "C. 信道容量\n" +
            "\n" +
            "D. 传输速率\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：频带利用率衡量单位带宽内的数据传输效率，是表征传输有效性的指标。误码率反映传输可靠性，信道容量是信道的最大传输能力，传输速率是单位时间传输的数据量，均不属于有效性指标。\n" +
            "\n" +
            "1.在下列传输介质中，哪种传输介质的抗电磁干扰性最好（）。\n" +
            "\n" +
            "A. 双绞线\n" +
            "\n" +
            "B. 同轴电缆\n" +
            "\n" +
            "C. 光缆\n" +
            "\n" +
            "D. 无线介质\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：光缆利用光信号传输数据，不受电磁干扰影响；双绞线和同轴电缆是电信号传输，易受电磁干扰；无线介质通过电磁波传输，也可能受电磁干扰。\n" +
            "\n" +
            "1.在串行通信中采用位同步技术的目的是（）。\n" +
            "\n" +
            "A. 更快地发送数据\n" +
            "\n" +
            "B. 更快地接收数据\n" +
            "\n" +
            "C. 更可靠的传输数据\n" +
            "\n" +
            "D. 更有效地传输数据\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：位同步技术用于确保收发双方的时钟同步，使接收方能准确识别数据位的起始和结束，避免因时钟偏差导致的数据错误，从而提高传输可靠性。\n" +
            "\n" +
            "1.以下压缩编码中，（）方法的压缩是有损的。\n" +
            "\n" +
            "A. Huffman 编码\n" +
            "\n" +
            "B. JPEG 编码\n" +
            "\n" +
            "C. Lempel-Ziv-Welch 编码\n" +
            "\n" +
            "D. Burrows-Wheeler 编码\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：JPEG 编码是有损压缩，通过丢弃部分人类视觉不敏感的图像信息来实现压缩，适用于图像文件。Huffman 编码、LZW 编码和 Burrows-Wheeler 编码均为无损压缩，常用于文本、程序等不能丢失数据的场景。\n" +
            "\n" +
            "1.关于 IP 主机地址，下列说法正确的是（）\n" +
            "\n" +
            "A. 地址主机部分可以全 1 也可以全 0\n" +
            "\n" +
            "B. IP 地址网段部分可以全 1 也可以全 0\n" +
            "\n" +
            "C. 地址网段部分不可以全 1 也不可以全 0\n" +
            "\n" +
            "D. IP 地址可以全 1 也可以全 0\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：IP 地址中，网络部分全 0 表示 “本网络”，全 1 为广播地址，均为保留地址，不能作为主机地址。主机部分全 0 表示网络地址，全 1 为广播地址，因此网段部分（网络地址）不能全 1 或全 0，主机部分也有相应保留规则。\n" +
            "\n" +
            "1.若两台主机在同一子网中，则两台主机的 IP 地址分别与它们的子网掩码相 “与” 的结果一定（）。\n" +
            "\n" +
            "A. 为全 0\n" +
            "\n" +
            "B. 为全 1\n" +
            "\n" +
            "C. 相同\n" +
            "\n" +
            "D. 不同\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：子网掩码用于标识 IP 地址的网络部分，同一子网内的主机 IP 地址与子网掩码按位相与后，得到的网络地址必须相同，否则不属于同一子网。\n" +
            "\n" +
            "1.用 TCP／IP 协议的网络在传输信息时，如果出了错误需要报告，采用的协议是 (）\n" +
            "\n" +
            "A. ICMP\n" +
            "\n" +
            "B. HTTP\n" +
            "\n" +
            "C. TCP\n" +
            "\n" +
            "D. SMTP\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：ICMP（互联网控制报文协议）用于在 IP 网络中传递控制信息，如错误报告、路由重定向等。HTTP 是应用层协议，用于网页传输；TCP 是传输层协议，提供可靠传输；SMTP 是邮件传输协议。\n" +
            "\n" +
            "1.关于 ARP 表，以下描述中正确的是（）。\n" +
            "\n" +
            "A. 提供常用目标地址的快捷方式来减少网络流量\n" +
            "\n" +
            "B. 用于建立 IP 地址到 MAC 地址的映射\n" +
            "\n" +
            "C. 用于在各个子网之间进行路由选择\n" +
            "\n" +
            "D. 用于进行应用层信息的转换\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：ARP（地址解析协议）表存储 IP 地址与 MAC 地址的映射关系，当主机需要发送数据时，通过 ARP 表快速获取目标 IP 对应的 MAC 地址，避免重复广播，从而减少网络流量。\n" +
            "\n" +
            "1.采用 TCP/IP 数据封装时，以下哪个端口号范围标识了所有常用应用程序（）。\n" +
            "\n" +
            "A. 0 到 255\n" +
            "\n" +
            "B. 256 到 1022\n" +
            "\n" +
            "C. 0 到 1023\n" +
            "\n" +
            "D. 1024 到 2047\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：TCP/IP 协议中，端口号 0 - 1023 为知名端口（Well-Known Ports），分配给常用应用程序，如 HTTP（80）、FTP（21）等；1024 以上为注册端口和动态端口。\n" +
            "\n" +
            "1.以下说法正确的是（）\n" +
            "\n" +
            "A. TCP 不可靠\n" +
            "\n" +
            "B. UDP 面向报文\n" +
            "\n" +
            "C. TCP 只有固定首部\n" +
            "\n" +
            "D. TCP 基于伪首部计算校验和，但 UDP 不是。\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：UDP 是无连接的传输层协议，面向报文，每个 UDP 数据包独立处理，不保证顺序和可靠性。TCP 是可靠协议，首部包含固定部分和可选部分，TCP 和 UDP 均基于伪首部计算校验和。\n" +
            "\n" +
            "1.以下说法错误的是（）。\n" +
            "\n" +
            "A. UDP 支持一对一、一对多、多对一、多对多的交互通信。\n" +
            "\n" +
            "B. TCP 是无连接的。\n" +
            "\n" +
            "C. UDP 不提供拥塞控制。\n" +
            "\n" +
            "D. UDP 不提供流量控制。\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：TCP 是面向连接的协议，通信前需建立三次握手连接；UDP 是无连接的。A、C、D 选项均正确，UDP 支持多播和广播，不提供拥塞和流量控制。\n" +
            "\n" +
            "1.TCP 协议属于 TCP/IP 模型的（）。\n" +
            "\n" +
            "A. 传输层\n" +
            "\n" +
            "B. 网络接口层\n" +
            "\n" +
            "C. 网络互联层\n" +
            "\n" +
            "D. 应用层\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：TCP/IP 模型分为四层：网络接口层、网络互联层（IP 层）、传输层（TCP/UDP 层）、应用层。TCP 协议属于传输层，负责端到端的可靠数据传输。\n" +
            "\n" +
            "1.下面四个选项中，合法的 Internet 主机 IP 地址是（）。\n" +
            "\n" +
            "A. 228.132.809.33\n" +
            "\n" +
            "B. 201.32.17.255\n" +
            "\n" +
            "C. 211.202.59.13\n" +
            "\n" +
            "D. 0.58.173.2\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：IP 地址由四个 0 - 255 的十进制数组成。A 选项中 809 超过 255，非法；B 选项 201.32.17.255 是广播地址；D 选项以 0 开头的 IP 地址通常用于特殊用途，不作为主机地址；C 选项符合规范。\n" +
            "\n" +
            "1.TCP 报头信息和 UDP 报头信息中都包含下列哪项信息（）。\n" +
            "\n" +
            "A. 定序\n" +
            "\n" +
            "B. 流量控制\n" +
            "\n" +
            "C. 确认\n" +
            "\n" +
            "D. 源和目的\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：TCP 和 UDP 报头均包含源端口号和目的端口号，用于标识发送和接收应用程序。定序、流量控制和确认是 TCP 特有的功能，UDP 报头中不包含这些字段。\n" +
            "\n" +
            "1.如果某个光纤网络的链路传输速度为 1000Gb/S，有一台巨型计算机向一台 PC 机以 1Gb/S 的速度传送文件，需要进行（）。\n" +
            "\n" +
            "A、差错控制\n" +
            "\n" +
            "B、拥塞控制\n" +
            "\n" +
            "C、流量控制\n" +
            "\n" +
            "D、死锁控制\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：流量控制用于解决发送方和接收方速度不匹配的问题，防止高速发送方淹没低速接收方。本题中光纤链路速度远高于 PC 接收速度，需通过流量控制（如滑动窗口机制）协调数据传输速率，避免数据丢失。拥塞控制针对网络整体拥堵，差错控制处理传输错误，死锁控制解决资源竞争，均与本题场景无关。\n" +
            "\n" +
            "1.下面关于 IPv6 协议优点的描述中，准确的是（）。\n" +
            "\n" +
            "A. IPv6 协议允许全局 IP 地址出现重复\n" +
            "\n" +
            "B. IPv6 协议解决了 IP 地址短缺的问题\n" +
            "\n" +
            "C. IPv6 协议支持通过卫星链路的 Internet 连接\n" +
            "\n" +
            "D. IPv6 协议支持光纤通信\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：IPv6 采用 128 位地址，地址空间约为 2^128 个，几乎不存在地址耗尽问题，彻底解决了 IPv4 地址短缺的问题。IPv6 不允许全局 IP 地址重复，其设计与传输介质（卫星、光纤）无关，而是网络层协议。\n" +
            "\n" +
            "1.某主机的 IP 地址为 140.252.20.68，子网掩码为 255.255.255.224，计算该主机所在子网的网络地址（采用 CIDR 地址表示法 a.b.c.d/x）是（）。\n" +
            "\n" +
            "A、140.252.20.64/26\n" +
            "B、140.252.20.64/28\n" +
            "C、140.252.20.64/27\n" +
            "D、140.252.20.32/27\n" +
            "答案：C\n" +
            "\n" +
            "解析：子网掩码 255.255.255.224 转换为二进制是 11111111.11111111.11111111.11100000，即网络位为 27 位（/27）。IP 地址 140.252.20.68 转换为二进制后，与子网掩码按位相与，得到网络地址：140.252.20.64（68 的二进制为 01000100，与 11100000 相与后为 01000000，即 64）。因此网络地址为 140.252.20.64/27。\n" +
            "\n" +
            "1.某主机的 IP 地址是 180.80.77.55，掩码为 255.255.252.0，若该主机向其所在的网络发送广播分组，则目的地址可能是（）。\n" +
            "\n" +
            "A、180.80.76.0\n" +
            "B、180.80.76.255\n" +
            "C、180.80.77.255\n" +
            "D、180.80.79.255\n" +
            "答案：D\n" +
            "\n" +
            "解析：掩码 255.255.252.0 转换为二进制是 11111111.11111111.11111100.00000000，即网络位为 22 位，主机位为 10 位。IP 地址 180.80.77.55 的网络部分为前 22 位，计算得网络地址为 180.80.76.0（77 的二进制为 01001101，与 11111100 相与后为 01001100，即 76）。广播地址是主机位全 1，即 180.80.76.0 的主机位（10 位）全置 1，得到 180.80.79.255（76 + 3 = 79，主机位全 1 为 255）。\n" +
            "\n" +
            "1.某公司申请到一个 C 类 IP 地址，但要连接 6 个的子公司，最大的一个子公司有 26 台计算机，每个子公司在一个网段中，则子网掩码应设为（）。\n" +
            "\n" +
            "A、255.255.255.0\n" +
            "B、255.255.255.128\n" +
            "C、255.255.255.192\n" +
            "D、255.255.255.224\n" +
            "答案：D\n" +
            "\n" +
            "解析：C 类 IP 地址默认掩码为 255.255.255.0，主机位为 8 位。需划分 6 个子网，且每个子网至少 26 台主机（26 + 2 = 28，含网络地址和广播地址）。子网位数需满足 2^n ≥ 6（n 为子网位数），n=3 时 2^3=8≥6；主机位数需满足 2^m ≥ 28（m 为主机位数），m=5 时 2^5=32≥28。因此子网掩码为 255.255.255.（11100000）即 255.255.255.224。\n" +
            "\n" +
            "1.IEEE 802.11 标准是关于（）的网络技术？\n" +
            "\n" +
            "A. 无线局域网（WLAN）\n" +
            "\n" +
            "B. 蜂窝网络（Cellular Network）\n" +
            "\n" +
            "C. 广域网（WAN）\n" +
            "\n" +
            "D. 有线局域网（LAN）\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：IEEE 802.11 是专门针对无线局域网（WLAN）制定的标准，定义了无线通信的物理层和媒体访问控制层规范，如 WiFi 即基于该标准。\n" +
            "\n" +
            "1.在以太网中，是根据（）地址来区分不同的设备的.\n" +
            "\n" +
            "A. LLC 地址\n" +
            "\n" +
            "B. MAC 地址\n" +
            "\n" +
            "C. IP 地址\n" +
            "\n" +
            "D. IPX 地址\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：以太网中通过 MAC 地址（物理地址）唯一标识网络设备，该地址烧录在网卡芯片中。IP 地址是逻辑地址，用于网络层路由；LLC 地址和 IPX 地址在以太网中不常用。\n" +
            "\n" +
            "1.下面哪种 LAN 是应用 CSMA/CD 协议的（）\n" +
            "\n" +
            "A、令牌环\n" +
            "\n" +
            "B、FDDI\n" +
            "\n" +
            "C、ETHERNET\n" +
            "\n" +
            "D、NOVELL\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：CSMA/CD（载波侦听多路访问 / 冲突检测）是传统以太网（Ethernet）使用的媒体访问控制协议，用于解决共享信道的访问冲突。令牌环和 FDDI 使用令牌传递协议，NOVELL 是网络操作系统，非具体 LAN 类型。\n" +
            "\n" +
            "1.以太网媒体访问控制技术 CSMA/CD 的机制是（）。\n" +
            "\n" +
            "A. 争用带宽\n" +
            "\n" +
            "B. 预约带宽\n" +
            "\n" +
            "C. 循环使用带宽\n" +
            "\n" +
            "D. 按优先级分配带宽\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：CSMA/CD 协议中，设备通过侦听信道是否空闲来竞争使用带宽，发现冲突后随机退避，属于争用型访问机制，而非预约、循环或按优先级分配。\n" +
            "\n" +
            "1.下面（）不是 IEEE 802.3ae 万兆以太网的主要特点。\n" +
            "\n" +
            "A. 速率为 1Gbit/s。\n" +
            "\n" +
            "B. 使用 IEEE 802.3 的帧格式 (与 10Mbit/s、100Mbit/s 和 1Gbit/s 以太网相同)。\n" +
            "\n" +
            "C. 保留 IEEE 802.3 标准对以太网最小帧长和最大帧长的规定。\n" +
            "\n" +
            "D. 不需要使用 CSMA/CD 协议。\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：IEEE 802.3ae 定义的是万兆以太网（10Gbit/s），而非 1Gbit/s。其保留了传统以太网的帧格式、最小和最大帧长，且由于全双工传输无冲突，无需 CSMA/CD 协议。\n" +
            "\n" +
            "1.一个 VLAN 可以看作是一个（）\n" +
            "\n" +
            "A、冲突域\n" +
            "\n" +
            "B、广播域\n" +
            "\n" +
            "C、管理域\n" +
            "\n" +
            "D、阻塞域\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：VLAN（虚拟局域网）将物理网络划分为逻辑子网，每个 VLAN 是一个独立的广播域，广播帧仅在本 VLAN 内传播，可减少广播风暴并提高网络安全性。冲突域由交换机端口或集线器定义，与 VLAN 无关。\n" +
            "\n" +
            "1.下面关于 VLAN 的描述中，正确的是（）。\n" +
            "\n" +
            "A. VLAN 是一种新型局域网。\n" +
            "\n" +
            "B. 不同 VLAN 之间的机器可以直接通过二层交换完成通信。\n" +
            "\n" +
            "C. 同一 VLAN 的机器之间可以直接通过二层交换完成通信。\n" +
            "\n" +
            "D. 连接在同一个交换机上的机器才能构成 VLAN。\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：同一 VLAN 内的设备属于同一广播域，可通过二层交换直接通信；不同 VLAN 间通信需三层设备（如路由器）转发。VLAN 是逻辑分组，并非新型物理局域网，且可跨交换机划分。\n" +
            "\n" +
            "1.VLAN 的划分不包括以下哪种方法？（）。\n" +
            "\n" +
            "A. 基于端口\n" +
            "\n" +
            "B. 基于 MAC 地址\n" +
            "\n" +
            "C. 基于协议\n" +
            "\n" +
            "D. 基于物理位置\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：VLAN 划分方法包括基于端口、MAC 地址、IP 地址、协议等，而基于物理位置并非标准的 VLAN 划分方式，物理位置不影响逻辑分组。\n" +
            "\n" +
            "1.下面说法正确的是（）。\n" +
            "\n" +
            "A. WiFi 是 IEEE802.11.\n" +
            "\n" +
            "B. ZigBee 是一种低功耗且简单的无线通信技术，它基于 IEEE 802.15.4 标准。\n" +
            "\n" +
            "C. 蓝牙技术是一种用于无线通信的长距离无线通信技术。\n" +
            "\n" +
            "D. IEEE 802.11ac 协议运行在 5GHz 频段。\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：ZigBee 是基于 IEEE 802.15.4 标准的低功耗、短距离无线通信技术，适用于物联网传感器网络。WiFi 是基于 IEEE 802.11 标准的认证商标，而非标准本身；蓝牙是短距离技术；IEEE 802.11ac 主要运行在 5GHz 频段，但选项 D 表述正确但不符合题意，B 选项更准确。\n" +
            "\n" +
            "1.（）不是保障局域网安全的措施。\n" +
            "\n" +
            "A. 配置防火墙\n" +
            "\n" +
            "B. 定期更新杀毒软件\n" +
            "\n" +
            "C. 安装 DDoS 攻击防御设备\n" +
            "\n" +
            "D. 将网线从路由器拔出并藏起来\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：配置防火墙、更新杀毒软件、安装 DDoS 防御设备均为主动安全措施，可有效保护局域网。而拔出网线属于物理断开，并非可持续的安全保障措施，且会导致网络不可用。\n" +
            "\n" +
            "1.TCP/IP 网络中常用的距离矢量路由协议是 (）。\n" +
            "\n" +
            "A. ARP\n" +
            "\n" +
            "B. ICMP\n" +
            "\n" +
            "C. OSPF\n" +
            "\n" +
            "D. RIP\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：RIP（路由信息协议）是典型的距离矢量路由协议，通过交换路由表和跳数信息来更新路由。OSPF 是链路状态路由协议，ARP 是地址解析协议，ICMP 是控制报文协议。\n" +
            "\n" +
            "1.在因特网中，IP 数据报从源结点到目的结点可能需要经过多个网络和路由器。在整个传输过程中，IP 数据报报头中的（）。\n" +
            "\n" +
            "A. 源地址和目的地址都不会发生变化\n" +
            "\n" +
            "B. 源地址有可能发生变化而目的地址不会发生变化\n" +
            "\n" +
            "C. 源地址不会发生变化而目的地址有可能发生变化\n" +
            "\n" +
            "D. 源地址和目的地址都有可能发生变化\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：IP 数据报在传输过程中，源 IP 地址（发送方）和目的 IP 地址（接收方）始终保持不变，路由器仅根据目的 IP 地址转发数据，不修改这两个地址，仅改变 MAC 地址。\n" +
            "\n" +
            "1.关于路由器，下列说法中正确的是（）。\n" +
            "\n" +
            "A. 路由器处理的信息量比交换机少，因而转发速度比交换机快\n" +
            "\n" +
            "B. 对于同一目标，路由器只提供延迟最小的最佳路由\n" +
            "\n" +
            "C. 通常的路由器可以支持多种网络层协议，并提供不同协议之间的分组转换\n" +
            "\n" +
            "D. 路由器不但能够根据逻辑地址进行转发，而且可以根据物理地址进行转发\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：路由器工作在网络层，可支持多种网络层协议（如 IP、IPX），并在不同协议间进行分组转换。交换机工作在数据链路层，转发速度通常比路由器快；路由器可根据多种度量值（如跳数、带宽）选择路由，并非仅延迟最小；路由器根据逻辑地址（IP）转发，而非物理地址（MAC）。\n" +
            "\n" +
            "1.关于静态路由，以下说法正确的是（）。\n" +
            "\n" +
            "A. 简单但开销大\n" +
            "\n" +
            "B. 能适应网络状态的变化\n" +
            "\n" +
            "C. 简单且开销小\n" +
            "\n" +
            "D. 复杂但开销小\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：静态路由由管理员手动配置，无需路由协议交互，因此配置简单、开销小，但无法自动适应网络拓扑变化，适用于结构简单的网络。\n" +
            "\n" +
            "1.（）不是动态路由协议的优点。\n" +
            "\n" +
            "A. 自动学习网络拓扑结构\n" +
            "\n" +
            "B. 提供负载均衡和容错能力\n" +
            "\n" +
            "C. 需要手动配置路由表\n" +
            "\n" +
            "D. 能够根据网络状况自动调整路由路径\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：动态路由协议的优点包括自动学习拓扑、自动调整路由、支持负载均衡和容错，而 “需要手动配置路由表” 是静态路由的特点，并非动态路由的优点。\n" +
            "\n" +
            "1.下面关于路由器的描述中，正确的是（）。\n" +
            "\n" +
            "A. 路由器中串口与以太口必须是成对的\n" +
            "\n" +
            "B. 路由器中串口与以太口的 IP 地址必须在同一网段\n" +
            "\n" +
            "C. 路由器的串口之间通常是点对点连接\n" +
            "\n" +
            "D. 路由器的以太口之间必须是点对点连接\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：路由器的串口常用于广域网连接，通常采用点对点链路（如 PPP 连接），两端串口直接相连。串口和以太口无需成对，IP 地址可属于不同网段；以太口用于局域网，可连接多个设备，并非必须点对点。\n" +
            "\n" +
            "1.OSPF 属于下列哪种类型的协议？（）。\n" +
            "\n" +
            "A. 内部路由协议\n" +
            "\n" +
            "B. 外部路由协议\n" +
            "\n" +
            "C. 混合路由协议\n" +
            "\n" +
            "D. 边界路由协议\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：OSPF（开放最短路径优先）是内部网关协议（IGP），用于自治系统（AS）内部的路由计算，属于链路状态路由协议，而非外部路由协议（如 BGP）。\n" +
            "\n" +
            "1.在一台功能完整的路由器中，能支持多种协议数据的转发。除此之外，还包括（）。\n" +
            "\n" +
            "A. 数据过滤\n" +
            "\n" +
            "B. 计费\n" +
            "\n" +
            "C. 网络管理\n" +
            "\n" +
            "D. 以上都是\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：现代路由器除基本的路由转发功能外，还具备数据过滤（ACL）、流量统计计费、SNMP 网络管理、QoS 服务质量控制等功能，以满足复杂网络环境的需求。\n" +
            "\n" +
            "1.以下各项中，不是数据报操作特点的是 (）\n" +
            "\n" +
            "A. 每个分组自身携带有足够的信息，它的传送是被单独处理的\n" +
            "\n" +
            "B. 在整个传送过程中，不需建立虚电路\n" +
            "\n" +
            "C. 使所有分组按顺序到达目的端系统\n" +
            "\n" +
            "D. 网络节点要为每个分组做出路由选择\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：数据报是无连接的网络服务，每个分组独立路由，可能沿不同路径传输，因此不一定按顺序到达目的端，需由上层协议（如 TCP）负责重组。A、B、D 选项均为数据报的特点。\n" +
            "\n" +
            "1.在分层次的路由选择协议中，（）描述了外部网关协议（EGP）的特点。\n" +
            "\n" +
            "A. EGP 适用于自治系统内的路由选择。\n" +
            "\n" +
            "B. EGP 使用链路状态路由选择算法进行路由计算。\n" +
            "\n" +
            "C. EGP 不能用于大规模复杂的网络环境。\n" +
            "\n" +
            "D. EGP 主要用于自治系统之间的路由选择。\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：EGP（外部网关协议）是早期用于自治系统（AS）之间的路由协议，采用距离矢量算法，适用于简单网络，不适用于大规模复杂网络（现多用 BGP）。A 选项错误，EGP 用于 AS 之间；B 选项错误，EGP 非链路状态算法。\n" +
            "\n" +
            "1.下列哪种广域网技术需要使用光纤作为传输媒介？ （）\n" +
            "\n" +
            "A. ADSL\n" +
            "\n" +
            "B. ISDN\n" +
            "\n" +
            "C. FTTX\n" +
            "\n" +
            "D. WiMAX\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：FTTX（光纤到 x）技术如 FTTH（光纤到户）、FTTB（光纤到楼）等，直接使用光纤作为传输介质，提供高速宽带接入。ADSL 和 ISDN 使用电话线，WiMAX 是无线广域网技术。\n" +
            "\n" +
            "1.在广域网中，下列哪种设备用于将网络流量从一个网络传输到另一个网络？ （）\n" +
            "\n" +
            "A. 路由器\n" +
            "\n" +
            "B. 交换机\n" +
            "\n" +
            "C. 防火墙\n" +
            "\n" +
            "D. 调制解调器\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：路由器工作在网络层，用于连接不同的网络（如局域网和广域网），根据 IP 地址转发数据包，实现网络间的流量传输。交换机用于局域网内，防火墙控制访问，调制解调器转换信号格式。\n" +
            "\n" +
            "1.FTTx＋LAN 接入网采用的传输介质为 （）\n" +
            "\n" +
            "A. 同轴电缆\n" +
            "\n" +
            "B. 光纤\n" +
            "\n" +
            "C. 5 类双绞线\n" +
            "\n" +
            "D. 光纤和 5 类双绞线\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：FTTx＋LAN 接入方式中，主干网使用光纤传输，到用户端通过 5 类双绞线接入局域网，形成 “光纤到小区 / 大楼 + 局域网到户” 的模式。\n" +
            "\n" +
            "1.接入因特网的方式有多种，下面关于各种接入方式的描述中，不正确的是（） 。\n" +
            "\n" +
            "A. 以终端方式入网，不需要 IP 地址\n" +
            "\n" +
            "B. 通过 PPP 拨号方式接入，需要有固定的 IP 地址\n" +
            "\n" +
            "C. 通过代理服务器接入，多个主机可以共享 1 个 IP 地址\n" +
            "\n" +
            "D. 通过局域网接入，可以有固定的 IP 地址，也可以用动态分配的 IP 地址\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：PPP 拨号接入通常由 ISP 动态分配 IP 地址，无需固定 IP；终端方式入网（如通过串口连接主机）不直接参与网络寻址，无需 IP 地址；代理服务器可实现多主机共享一个公网 IP；局域网接入可使用固定或动态 IP（如 DHCP 分配）。\n" +
            "\n" +
            "1.在 HFC 网络中，Cable Modem 的作用是 （）\n" +
            "\n" +
            "A. 用于调制解调和拨号上网\n" +
            "\n" +
            "B. 用于调制解调及作为以太网接口\n" +
            "\n" +
            "C. 用于连接电话线和用户终端计算机\n" +
            "\n" +
            "D. 连接 ISDN 接口和用户终端计算机\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：HFC（混合光纤同轴电缆）网络中，Cable Modem 将同轴电缆传输的射频信号转换为数字信号（调制解调），并提供以太网接口连接用户计算机，实现有线电视网络的宽带接入。\n" +
            "\n" +
            "1.VPN 主要使用了哪些技术来保证通信的安全性？ （）\n" +
            "\n" +
            "A. 隧道技术、身份认证、日志记录和访问控制\n" +
            "\n" +
            "B. 隧道技术、加密、身份认证和防火墙\n" +
            "\n" +
            "C. 隧道技术、加密、身份认证和虚拟专用网络\n" +
            "\n" +
            "D. 隧道技术、加密、日志记录和虚拟专用网络\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：VPN（虚拟专用网络）通过隧道技术封装数据，使用加密算法保护数据传输，通过身份认证确保用户合法性，并结合防火墙控制访问权限，从而保证通信安全。日志记录是安全审计的一部分，而非 VPN 核心技术。\n" +
            "\n" +
            "1.下列哪种协议用于广域网中的数据链路层？ (）\n" +
            "\n" +
            "A. TCP\n" +
            "\n" +
            "B. UDP\n" +
            "\n" +
            "C. PPP\n" +
            "\n" +
            "D. RIP\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：PPP（点到点协议）是广域网中常用的数据链路层协议，用于点到点链路（如拨号上网、光纤专线），提供链路建立、维护和终止等功能。TCP 和 UDP 是传输层协议，RIP 是网络层路由协议。\n" +
            "\n" +
            "1.光纤接入技术的主要优点是什么？ (）\n" +
            "\n" +
            "A. 传输速度快，传输距离长\n" +
            "\n" +
            "B. 安全性高，抗干扰能力强\n" +
            "\n" +
            "C. 安装方便，维护成本低\n" +
            "\n" +
            "D. 以上都是\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：光纤接入的优点包括：\n" +
            "\n" +
            "•传输速度快，可达千兆甚至万兆。\n" +
            "\n" +
            "•传输距离长，损耗低。\n" +
            "\n" +
            "•安全性高，光信号不易被窃听。\n" +
            "\n" +
            "•抗电磁干扰能力强。\n" +
            "\n" +
            "•安装相对方便，维护成本低于铜缆。\n" +
            "\n" +
            "1.ADSL 是一种宽带接入技术，这种技术使用的传输介质是 (）\n" +
            "\n" +
            "A. 电话线\n" +
            "\n" +
            "B. CATV 电缆\n" +
            "\n" +
            "C. 基带同轴电缆\n" +
            "\n" +
            "D. 无线通信网\n" +
            "\n" +
            "答案：A\n" +
            "\n" +
            "解析：ADSL（非对称数字用户线）利用现有的普通电话线传输宽带信号，通过频分复用技术在同一线路上同时传输语音和数据，无需重新布线。\n" +
            "\n" +
            "1.NAT 技术通常用于解决什么类型的问题？ (）\n" +
            "\n" +
            "A. 局域网内部 IP 地址冲突\n" +
            "\n" +
            "B. 不同局域网之间无法通信\n" +
            "\n" +
            "C. 内部网络地址无法访问外部网络\n" +
            "\n" +
            "D. 以上所有选项\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：NAT（网络地址转换）主要解决以下问题：\n" +
            "\n" +
            "•局域网使用私有 IP 地址，通过 NAT 转换为公有 IP 以访问外部网络。\n" +
            "\n" +
            "•缓解 IP 地址短缺，多个内部主机共享一个公网 IP。\n" +
            "\n" +
            "•隐藏内部网络结构，提高安全性。\n" +
            "\n" +
            "•解决不同局域网间因 IP 地址冲突导致的通信问题。\n" +
            "\n" +
            "1.下面协议中，用于 WWW 传输控制的是 (）\n" +
            "\n" +
            "A. URL\n" +
            "\n" +
            "B. SMTP\n" +
            "\n" +
            "C. HTTP\n" +
            "\n" +
            "D. HTML\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：HTTP（超文本传输协议）是 WWW 服务的核心协议，用于浏览器与 Web 服务器之间传输网页数据。URL 是网页地址格式，SMTP 是邮件传输协议，HTML 是网页内容格式。\n" +
            "\n" +
            "1.域名服务器上存放有 Internet 主机的 (）\n" +
            "\n" +
            "A. 域名\n" +
            "\n" +
            "B. IP 地址\n" +
            "\n" +
            "C. 域名和 IP 地址\n" +
            "\n" +
            "D. E-mail 地址\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：域名服务器（DNS）存储域名与 IP 地址的映射关系，当用户输入域名时，DNS 服务器将其解析为对应的 IP 地址，以便网络设备进行数据传输。\n" +
            "\n" +
            "1.在 Internet 域名体系中，域的下面可以划分子域，各级域名用圆点分开，按照 (）\n" +
            "\n" +
            "A、从左到右越来越小的方式分 4 层排列\n" +
            "\n" +
            "B、从左到右越来越小的方式分多层排列\n" +
            "\n" +
            "C、从右到左越来越小的方式分 4 层排列\n" +
            "\n" +
            "D、从右到左越来越小的方式分多层排列\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：域名的层次结构从右到左依次为顶级域（如.com）、二级域（如 microsoft）、子域（如 www），即从右到左级别逐渐降低，可分为多层，非固定 4 层。\n" +
            "\n" +
            "1.在 Internet 上浏览时，浏览器和 WWW 服务器之间传输网页使用的协议是 (）\n" +
            "\n" +
            "A、IP\n" +
            "\n" +
            "B、HTTP\n" +
            "\n" +
            "C、FTP\n" +
            "\n" +
            "D、Telnet\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：同第 1 题，浏览器与 Web 服务器通过 HTTP 协议传输网页，IP 是网络层协议，FTP 用于文件传输，Telnet 用于远程登录。\n" +
            "\n" +
            "1.在 Internet/Intranet 中，不需要为用户设置帐号和口令的服务是 (）\n" +
            "\n" +
            "A、WWW\n" +
            "\n" +
            "B、FTP\n" +
            "\n" +
            "C、E-mail\n" +
            "\n" +
            "D、DNS\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：DNS 是域名解析服务，用户访问时自动使用，无需账号口令；WWW、FTP、E-mail 服务通常需要用户认证（公开访问的 WWW 除外，但仍需账号的情况更常见）。\n" +
            "\n" +
            "1.下面协议中，用于电子邮件 Email 传输控制的是 (）\n" +
            "\n" +
            "A. SNMP\n" +
            "\n" +
            "B. SMTP\n" +
            "\n" +
            "C. HTTP\n" +
            "\n" +
            "D. HTML\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：SMTP（简单邮件传输协议）用于发送和传输电子邮件，SNMP 是网络管理协议，HTTP 用于网页传输，HTML 是网页格式。\n" +
            "\n" +
            "1.Internet 是建立在（）协议集上的国际互联网络。\n" +
            "\n" +
            "A. IPX\n" +
            "\n" +
            "B. NetBEUI\n" +
            "\n" +
            "C. TCP/IP\n" +
            "\n" +
            "D. AppleTalk\n" +
            "\n" +
            "答案：C\n" +
            "\n" +
            "解析：TCP/IP 协议集是 Internet 的基础，定义了网络层（IP）、传输层（TCP/UDP）和应用层的标准，其他协议（IPX、NetBEUI、AppleTalk）用于特定局域网环境。\n" +
            "\n" +
            "1.关于 Internet，以下说法正确的是（）。\n" +
            "\n" +
            "A. Internet 属于美国\n" +
            "\n" +
            "B. Internet 属于联合国\n" +
            "\n" +
            "C. Internet 属于国际红十字会\n" +
            "\n" +
            "D. Internet 不属于某个国家或组织\n" +
            "\n" +
            "答案：D\n" +
            "\n" +
            "解析：同第一部分第 5 题，Internet 是全球性的开放网络，没有单一的管理机构或归属主体，不属于任何国家或组织。\n" +
            "\n" +
            "1.以下列举的关于 Internet 的各功能中，错误的是（）。\n" +
            "\n" +
            "A. 程序编码\n" +
            "\n" +
            "B. 信息查询\n" +
            "\n" +
            "C. 数据库检索\n" +
            "\n" +
            "D. 电子函件传送 \n" +
            "答案：A\n" +
            "\n" +
            "解析：Internet 提供信息查询、数据库检索、电子邮件、文件传输等功能，而程序编码是软件开发人员的本地工作，并非 Internet 直接提供的功能。\n" +
            "\n" +
            "1.在 Internet 中，某 WWW 服务器提供的网页地址为http://www.microsoft.com，其中的 “http” 指的是（）。\n" +
            "\n" +
            "A. WWW 服务器主机名\n" +
            "\n" +
            "B. 访问类型为超文本传输协议\n" +
            "\n" +
            "C. 访问类型为文件传输协议\n" +
            "\n" +
            "D. WWW 服务器域名\n" +
            "\n" +
            "答案：B\n" +
            "\n" +
            "解析：URL 中的 “http” 是协议标识符，指定使用超文本传输协议（HTTP）访问服务器，“www.microsoft.com” 是服务器域名，文件传输协议为 FTP。\n";

    // 现代化配色方案
    private static final Color PRIMARY_BLUE = new Color(30, 144, 255);
    private static final Color LIGHT_BG = new Color(240, 245, 255);
    private static final Color CARD_BG = new Color(255, 255, 255);
    private static final Color ACCENT_BLUE = new Color(41, 128, 185);
    private static final Color BUTTON_HOVER = new Color(39, 118, 168);
    private static final Color SELECTED_COLOR = new Color(210, 230, 255);
    private static final Color TEXT_COLOR = new Color(50, 50, 50);
    private static final Color SUBTLE_BORDER = new Color(220, 230, 240);

    private static class Question {
        private String number;
        private String content;
        private String options;
        private String answer;
        private String analysis;
        private List<String> userAnswer;

        public Question(String number, String content, String options, String answer, String analysis) {
            this.number = number;
            this.content = content;
            this.options = options;
            this.answer = answer;
            this.analysis = analysis;
            this.userAnswer = new ArrayList<>();
        }

        public String getContentWithHiddenAnswer() { return content; }
        public String getOriginalContent() { return content; }
        public String getNumber() { return number; }
        public String getOptions() { return options; }
        public String getAnswer() { return answer; }
        public String getAnalysis() { return analysis; }
        public void setUserAnswer(List<String> userAnswer) { this.userAnswer = userAnswer; }
        public List<String> getUserAnswer() { return userAnswer; }
        public boolean isAnswered() { return !userAnswer.isEmpty(); }
        public boolean isMultipleChoice() { return answer.length() > 1; }
    }

    private List<Question> questions = new ArrayList<>();
    private int currentQuestionIndex = 0;
    private JTextArea questionArea;
    private JButton prevBtn, nextBtn, submitBtn, showAnswerBtn, loadBtn;
    private JLabel questionNumLabel, statusLabel;
    private JPanel controlPanel, optionPanel;
    private boolean isAnswering = true;

    // 用于存储选项按钮的数组
    private JButton[] optionButtons = new JButton[8]; // 支持最多8个选项(A-H)

    public OptimizedQuizApp() {
        setTitle("计算机网络题库       [计算机网络技术（2025-6-25）14:20-16:20 考场：502]");
        setSize(950, 800);
        setResizable(false);

        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
        initComponents();
        layoutComponents();
        addEventHandlers();
        loadQuestionsFromString();

        setVisible(true);
    }

    private void initComponents() {
        // 使用现代化字体
        Font titleFont = new Font("微软雅黑", Font.BOLD, 22);
        Font contentFont = new Font("微软雅黑", Font.PLAIN, 18);
        Font buttonFont = new Font("微软雅黑", Font.BOLD, 16);
        Font smallFont = new Font("微软雅黑", Font.PLAIN, 14);

        // 题目区域样式
        questionArea = new JTextArea();
        questionArea.setEditable(false);
        questionArea.setLineWrap(true);
        questionArea.setWrapStyleWord(true);
        questionArea.setFont(contentFont);
        questionArea.setBorder(new CompoundBorder(
                new LineBorder(SUBTLE_BORDER, 1),
                new EmptyBorder(20, 20, 20, 20)
        ));
        questionArea.setBackground(CARD_BG);
        questionArea.setForeground(TEXT_COLOR);

        // 创建现代化按钮
        prevBtn = createModernButton("上一题", buttonFont);
        nextBtn = createModernButton("下一题", buttonFont);
        submitBtn = createModernButton("提交答案", buttonFont);
        showAnswerBtn = createModernButton("显示解析", buttonFont);
        loadBtn = createModernButton("重新加载", buttonFont);

        // 标签样式
        questionNumLabel = new JLabel("题目: 0/0");
        questionNumLabel.setFont(new Font("微软雅黑", Font.BOLD, 16));
        questionNumLabel.setForeground(TEXT_COLOR);

        statusLabel = new JLabel("准备开始答题...");
        statusLabel.setFont(new Font("微软雅黑", Font.PLAIN, 14));
        statusLabel.setForeground(TEXT_COLOR);

        // 选项面板
        optionPanel = new JPanel();
        optionPanel.setLayout(new GridLayout(0, 2, 10, 10));
        optionPanel.setBackground(CARD_BG);
        optionPanel.setBorder(new EmptyBorder(20, 20, 20, 20));

        // 初始化选项按钮
        for (int i = 0; i < optionButtons.length; i++) {
            char optionLetter = (char)('A' + i);
            optionButtons[i] = createOptionButton(optionLetter, smallFont);
            optionPanel.add(optionButtons[i]);
            optionButtons[i].setEnabled(false);
        }

        // 控制面板样式
        controlPanel = new JPanel();
        controlPanel.setBackground(LIGHT_BG);
        controlPanel.setBorder(new EmptyBorder(10, 20, 10, 20));
    }

    private JButton createModernButton(String text, Font font) {
        JButton button = new JButton(text) {
            @Override
            protected void paintComponent(Graphics g) {
                Graphics2D g2 = (Graphics2D) g.create();
                g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                if (getModel().isPressed()) {
                    g2.setColor(BUTTON_HOVER.darker());
                } else if (getModel().isRollover()) {
                    g2.setColor(BUTTON_HOVER);
                } else {
                    g2.setColor(ACCENT_BLUE);
                }

                g2.fillRoundRect(0, 0, getWidth(), getHeight(), 10, 10);
                g2.setColor(Color.WHITE);
                g2.setFont(font);
                FontMetrics fm = g2.getFontMetrics();
                int x = (getWidth() - fm.stringWidth(getText())) / 2;
                int y = ((getHeight() - fm.getHeight()) / 2) + fm.getAscent();
                g2.drawString(getText(), x, y);
                g2.dispose();
            }

            @Override
            protected void paintBorder(Graphics g) {
                // 无边框
            }
        };

        button.setContentAreaFilled(false);
        button.setBorderPainted(false);
        button.setFocusPainted(false);
        button.setPreferredSize(new Dimension(120, 40));
        button.setForeground(Color.WHITE);
        button.setFont(font);

        // 添加悬停效果
        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                button.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                button.setCursor(Cursor.getDefaultCursor());
            }
        });

        return button;
    }

    private JButton createOptionButton(char optionLetter, Font font) {
        JButton button = new JButton("" + optionLetter) {
            @Override
            protected void paintComponent(Graphics g) {
                Graphics2D g2 = (Graphics2D) g.create();
                g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                // 默认样式
                g2.setColor(Color.WHITE);
                g2.fillRoundRect(0, 0, getWidth(), getHeight(), 8, 8);
                g2.setColor(TEXT_COLOR);
                g2.drawRoundRect(0, 0, getWidth() - 1, getHeight() - 1, 8, 8);

                // 选中样式
                if (getBackground() == SELECTED_COLOR) {
                    g2.setColor(SELECTED_COLOR);
                    g2.fillRoundRect(1, 1, getWidth() - 2, getHeight() - 2, 6, 6);
                    g2.setColor(ACCENT_BLUE);
                }
                // 悬停样式
                else if (getModel().isRollover()) {
                    g2.setColor(new Color(210, 230, 255));
                    g2.fillRoundRect(1, 1, getWidth() - 2, getHeight() - 2, 6, 6);
                    g2.setColor(TEXT_COLOR);
                }
                // 按下样式
                else if (getModel().isPressed()) {
                    g2.setColor(new Color(230, 240, 255));
                    g2.fillRoundRect(1, 1, getWidth() - 2, getHeight() - 2, 6, 6);
                    g2.setColor(TEXT_COLOR);
                }

                g2.setFont(font);
                FontMetrics fm = g2.getFontMetrics();
                int x = (getWidth() - fm.stringWidth(getText())) / 2;
                int y = ((getHeight() - fm.getHeight()) / 2) + fm.getAscent();
                g2.drawString(getText(), x, y);
                g2.dispose();
            }

            @Override
            protected void paintBorder(Graphics g) {
                // 无边框
            }
        };

        button.setContentAreaFilled(false);
        button.setBorderPainted(false);
        button.setFocusPainted(false);
        button.setPreferredSize(new Dimension(100, 40));
        button.setForeground(TEXT_COLOR);
        button.setFont(font);

        // 添加悬停效果
        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                button.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                button.setCursor(Cursor.getDefaultCursor());
            }
        });

        return button;
    }

    private void layoutComponents() {
        // 主面板使用现代化布局
        JPanel mainPanel = new JPanel(new BorderLayout(15, 15));
        mainPanel.setBorder(new EmptyBorder(15, 15, 15, 15));
        mainPanel.setBackground(LIGHT_BG);

        // 创建标题面板
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBackground(new Color(0, 0, 0, 0));
        titlePanel.setBorder(new EmptyBorder(0, 0, 15, 0));

        JLabel titleLabel = new JLabel("计算机网络题库");
        titleLabel.setFont(new Font("微软雅黑", Font.BOLD, 24));
        titleLabel.setForeground(PRIMARY_BLUE);
        titlePanel.add(titleLabel, BorderLayout.WEST);

        JLabel authorLabel = new JLabel("Copyright © 2025 Wings of Redemption");
        authorLabel.setFont(new Font("微软雅黑", Font.ITALIC, 14));
        authorLabel.setForeground(new Color(100, 100, 120));
        titlePanel.add(authorLabel, BorderLayout.EAST);

        mainPanel.add(titlePanel, BorderLayout.NORTH);

        // 内容区域使用卡片式设计
        JPanel contentPanel = new JPanel(new BorderLayout(10, 10));
        contentPanel.setBackground(LIGHT_BG);

        // 题目卡片
        JPanel questionCard = new JPanel(new BorderLayout());
        questionCard.setBackground(CARD_BG);
        questionCard.setBorder(new CompoundBorder(
                new LineBorder(SUBTLE_BORDER, 1),
                new EmptyBorder(5, 5, 5, 5)
        ));
        JScrollPane questionScroll = new JScrollPane(questionArea);
        questionScroll.setBorder(null);
        questionCard.add(questionScroll, BorderLayout.CENTER);

        // 选项卡片
        JPanel optionCard = new JPanel(new BorderLayout());
        optionCard.setBackground(CARD_BG);
        optionCard.setBorder(new CompoundBorder(
                new TitledBorder(new LineBorder(SUBTLE_BORDER, 1), "请选择答案"),
                new EmptyBorder(5, 5, 5, 5)
        ));
        optionCard.add(optionPanel, BorderLayout.CENTER);

        // 使用分割面板
        JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, questionCard, optionCard);
        splitPane.setDividerLocation(350);
        splitPane.setDividerSize(8);
        splitPane.setBackground(LIGHT_BG);

        contentPanel.add(splitPane, BorderLayout.CENTER);
        mainPanel.add(contentPanel, BorderLayout.CENTER);

        // 控制面板布局
        controlPanel.setLayout(new BoxLayout(controlPanel, BoxLayout.X_AXIS));
        controlPanel.add(Box.createHorizontalStrut(10));
        controlPanel.add(loadBtn);
        controlPanel.add(Box.createHorizontalStrut(10));
        controlPanel.add(statusLabel);
        controlPanel.add(Box.createHorizontalGlue());
        controlPanel.add(questionNumLabel);
        controlPanel.add(Box.createHorizontalStrut(20));
        controlPanel.add(prevBtn);
        controlPanel.add(Box.createHorizontalStrut(10));
        controlPanel.add(nextBtn);
        controlPanel.add(Box.createHorizontalStrut(10));
        controlPanel.add(submitBtn);
        controlPanel.add(Box.createHorizontalStrut(10));
        controlPanel.add(showAnswerBtn);
        controlPanel.add(Box.createHorizontalStrut(10));

        mainPanel.add(controlPanel, BorderLayout.SOUTH);
        add(mainPanel);
    }

    private void addEventHandlers() {
        prevBtn.addActionListener(e -> {
            if (questions.isEmpty()) return;
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion();
            }
        });

        nextBtn.addActionListener(e -> {
            if (questions.isEmpty()) return;
            if (currentQuestionIndex < questions.size() - 1) {
                currentQuestionIndex++;
                displayQuestion();
            }
        });

        submitBtn.addActionListener(e -> {
            if (questions.isEmpty()) return;
            showAnswerComparison();
        });

        showAnswerBtn.addActionListener(e -> {
            if (questions.isEmpty()) return;
            showAnalysis();
        });

        loadBtn.addActionListener(e -> loadQuestionsFromString());

        // 为选项按钮添加事件监听
        for (int i = 0; i < optionButtons.length; i++) {
            final int index = i;
            optionButtons[i].addActionListener(e -> {
                selectOption((char)('A' + index));
            });
        }
    }

    private void updateButtonStates() {
        if (isAnswering) {
            showAnswerBtn.setText("显示解析");
            submitBtn.setEnabled(true);
            for (JButton btn : optionButtons) {
                btn.setEnabled(!btn.getText().equals(""));
            }
        } else {
            showAnswerBtn.setText("显示解析");
            submitBtn.setEnabled(false);
            for (JButton btn : optionButtons) {
                btn.setEnabled(false);
            }
        }
    }

    private void selectOption(char option) {
        Question current = questions.get(currentQuestionIndex);
        String optionStr = String.valueOf(option);
        List<String> userAnswer = current.getUserAnswer();

        // 切换选项的选中状态
        if (userAnswer.contains(optionStr)) {
            userAnswer.remove(optionStr);
            optionButtons[option - 'A'].setBackground(Color.WHITE);
        } else {
            userAnswer.add(optionStr);
            optionButtons[option - 'A'].setBackground(SELECTED_COLOR);
        }

        // 更新状态标签
        if (userAnswer.isEmpty()) {
            statusLabel.setText("请选择答案");
        } else {
            Collections.sort(userAnswer);
            statusLabel.setText("已选择: " + String.join("", userAnswer));
        }
    }

    private void showAnswerComparison() {
        if (questions.isEmpty()) return;
        Question current = questions.get(currentQuestionIndex);
        List<String> userAnswer = current.getUserAnswer();

        if (userAnswer.isEmpty()) {
            JOptionPane.showMessageDialog(this, "请先选择答案", "提示", JOptionPane.WARNING_MESSAGE);
            return;
        }

        String userAnswerStr = String.join("", userAnswer);
        String correctAnswer = current.getAnswer();

        String message = "你的选择: " + userAnswerStr + "\n" +
                "正确答案: " + correctAnswer;

        JOptionPane.showMessageDialog(this, message, "答案对比", JOptionPane.INFORMATION_MESSAGE);

        statusLabel.setText("已记录你的选择");
        statusLabel.setForeground(TEXT_COLOR);
    }

    private void showAnalysis() {
        if (questions.isEmpty()) return;
        Question current = questions.get(currentQuestionIndex);

        // 显示解析内容
        String message = "解析:\n\n" + current.getAnalysis();

        JDialog dialog = new JDialog(this, "题目解析", true);
        dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);

        JTextArea textArea = new JTextArea(message);
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 16));
        textArea.setEditable(false);
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);

        JScrollPane scrollPane = new JScrollPane(textArea);
        scrollPane.setPreferredSize(new Dimension(600, 400));

        dialog.add(scrollPane);
        dialog.pack();
        dialog.setLocationRelativeTo(this);

        // 监听对话框关闭事件
        dialog.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosed(WindowEvent e) {
                statusLabel.setText("准备回答问题");
                statusLabel.setForeground(TEXT_COLOR);
            }
        });

        statusLabel.setText("查看题目解析");
        statusLabel.setForeground(TEXT_COLOR);

        dialog.setVisible(true);
    }

    private void loadQuestionsFromString() {
        SwingUtilities.invokeLater(() -> {
            statusLabel.setText("正在解析题目内容...");
            statusLabel.setForeground(TEXT_COLOR);
            isAnswering = true;

            new Thread(() -> {
                try {
                    questions.clear();
                    String[] lines = quest.split("\n");
                    StringBuilder currentContent = new StringBuilder();
                    StringBuilder currentOptions = new StringBuilder();
                    StringBuilder currentAnalysis = new StringBuilder();
                    String currentNumber = "";
                    String currentAnswer = "";
                    boolean isReadingOptions = false;
                    boolean isReadingAnalysis = false;
                    int questionCount = 0;

                    Pattern questionPattern = Pattern.compile("^(\\d+)[.、)]\\s*(.*)");
                    Pattern optionPattern = Pattern.compile("^[A-Z][.、)]");
                    Pattern analysisPattern = Pattern.compile("^解析：|^解析:");

                    for (String line : lines) {
                        line = line.trim();
                        if (line.isEmpty()) continue;

                        if (analysisPattern.matcher(line).find()) {
                            isReadingOptions = false;
                            isReadingAnalysis = true;
                            currentAnalysis = new StringBuilder(line.substring(line.indexOf(
                                    line.contains("：") ? "：" : ":"
                            ) + 1).trim());
                            continue;
                        }

                        if (line.startsWith("答案：") || line.startsWith("答案:")) {
                            String answerPart = line.substring(line.indexOf(
                                    line.contains("：") ? "：" : ":"
                            ) + 1).trim();
                            if (answerPart.length() >= 2 && answerPart.charAt(0) == ' ') {
                                currentAnswer = answerPart.substring(1);
                            } else {
                                currentAnswer = answerPart;
                            }

                            isReadingOptions = false;
                            isReadingAnalysis = false;
                            continue;
                        }

                        Matcher questionMatcher = questionPattern.matcher(line);
                        if (questionMatcher.find()) {
                            if (!currentNumber.isEmpty()) {
                                questions.add(new Question(
                                        currentNumber,
                                        currentContent.toString().trim(),
                                        currentOptions.toString().trim(),
                                        currentAnswer,
                                        currentAnalysis.toString().trim()
                                ));
                                questionCount++;
                            }

                            currentNumber = questionMatcher.group(1) + ".";
                            currentContent = new StringBuilder(questionMatcher.group(2).trim());
                            currentOptions = new StringBuilder();
                            currentAnalysis = new StringBuilder();
                            currentAnswer = "";
                            isReadingOptions = false;
                            isReadingAnalysis = false;
                        } else if (optionPattern.matcher(line).find()) {
                            isReadingOptions = true;
                            currentOptions.append(line).append("\n");
                        } else if (isReadingAnalysis) {
                            currentAnalysis.append(line).append(" ");
                        } else if (!isReadingOptions && !currentNumber.isEmpty()) {
                            currentContent.append(" ").append(line);
                        } else if (isReadingOptions && !currentNumber.isEmpty()) {
                            currentOptions.append(line).append("\n");
                        }
                    }

                    if (!currentNumber.isEmpty()) {
                        questions.add(new Question(
                                currentNumber,
                                currentContent.toString().trim(),
                                currentOptions.toString().trim(),
                                currentAnswer,
                                currentAnalysis.toString().trim()
                        ));
                        questionCount++;
                    }

                    SwingUtilities.invokeLater(() -> {
                        if (questions.isEmpty()) {
                            statusLabel.setText("加载失败：未找到有效题目");
                            statusLabel.setForeground(new Color(231, 76, 60));
                            JOptionPane.showMessageDialog(this,
                                    "未找到有效题目，请确认字符串格式是否正确",
                                    "加载失败",
                                    JOptionPane.ERROR_MESSAGE);
                        } else {
                            statusLabel.setText("成功加载 " + questions.size() + " 道题目");
                            statusLabel.setForeground(new Color(46, 204, 113));
                            currentQuestionIndex = 0;
                            displayQuestion();
                            prevBtn.setEnabled(true);
                            nextBtn.setEnabled(true);
                            submitBtn.setEnabled(true);
                            showAnswerBtn.setEnabled(true);
                            questionNumLabel.setText("题目: " + (currentQuestionIndex + 1) + "/" + questions.size());
                        }
                    });
                } catch (Exception ex) {
                    ex.printStackTrace();
                    SwingUtilities.invokeLater(() -> {
                        statusLabel.setText("加载失败：" + ex.getMessage());
                        statusLabel.setForeground(new Color(231, 76, 60));
                        JOptionPane.showMessageDialog(this,
                                "加载题目失败: " + ex.getMessage(),
                                "错误",
                                JOptionPane.ERROR_MESSAGE);
                    });
                }
            }).start();
        });
    }

    private void displayQuestion() {
        if (questions.isEmpty()) {
            questionArea.setText("请先加载选择题");
            for (JButton btn : optionButtons) {
                btn.setText("");
                btn.setEnabled(false);
            }
            return;
        }

        Question current = questions.get(currentQuestionIndex);
        questionArea.setText(current.getNumber() + " " + current.getContentWithHiddenAnswer());

        // 解析选项并显示
        String[] options = current.getOptions().split("\n");
        for (int i = 0; i < optionButtons.length; i++) {
            if (i < options.length && !options[i].trim().isEmpty()) {
                optionButtons[i].setText(options[i].trim());
                optionButtons[i].setEnabled(isAnswering);
                optionButtons[i].setBackground(Color.WHITE); // 重置按钮颜色
            } else {
                optionButtons[i].setText("");
                optionButtons[i].setEnabled(false);
            }
        }

        // 恢复用户之前的选择
        List<String> userAnswer = current.getUserAnswer();
        for (String option : userAnswer) {
            int index = option.charAt(0) - 'A';
            if (index >= 0 && index < optionButtons.length) {
                optionButtons[index].setBackground(SELECTED_COLOR);
            }
        }

        if (userAnswer.isEmpty()) {
            statusLabel.setText("请选择答案");
        } else {
            Collections.sort(userAnswer);
            statusLabel.setText("已选择: " + String.join("", userAnswer));
        }

        questionNumLabel.setText("题目: " + (currentQuestionIndex + 1) + "/" + questions.size());
    }

    public static void main(String[] args) {
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (Exception e) {
            e.printStackTrace();
        }

        SwingUtilities.invokeLater(() -> {
            OptimizedQuizApp app = new OptimizedQuizApp();
            app.setResizable(false);
            app.setVisible(true);
        });
    }
}